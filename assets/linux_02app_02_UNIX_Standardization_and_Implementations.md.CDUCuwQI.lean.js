import{_ as e,c as a,a2 as r,o as t}from"./chunks/framework.DRc6tsBz.js";const i=JSON.parse('{"title":"Advanced Programming in the UNIX® Environment","description":"","frontmatter":{"title":"Advanced Programming in the UNIX® Environment","date":"2021-07-07T01:42:30.000Z"},"headers":[],"relativePath":"linux/02app/02_UNIX_Standardization_and_Implementations.md","filePath":"linux/02app/02_UNIX_Standardization_and_Implementations.md","lastUpdated":1713886889000}');const n=e({name:"linux/02app/02_UNIX_Standardization_and_Implementations.md"},[["render",function(e,i,n,p,l,o){return t(),a("div",null,i[0]||(i[0]=[r('<h2 id="系统调用" tabindex="-1">系统调用 <a class="header-anchor" href="#系统调用" aria-label="Permalink to &quot;系统调用&quot;">​</a></h2><p><strong>系统调用</strong>（英语：system call），指运行在<a href="https://zh.wikipedia.org/wiki/%E4%BD%BF%E7%94%A8%E8%80%85%E7%A9%BA%E9%96%93" target="_blank" rel="noreferrer">用户空间</a>的<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F" target="_blank" rel="noreferrer">程序</a>向<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%B5%B1" target="_blank" rel="noreferrer">操作系统</a><a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8" target="_blank" rel="noreferrer">内核</a>请求需要更高权限运行的服务。系统调用提供用户程序与<a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%B5%B1" target="_blank" rel="noreferrer">操作系统</a>之间的接口。大多数系统交互式操作需求在内核态运行。如设备IO操作或者进程间通信。</p><p>顾名思义，说的是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务，比如用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获得系统时间或设置定时器等。</p><p>从逻辑上来说，系统调用可被看成是一个内核与用户空间程序交互的接口——它好比一个中间人，把用户进程的请求传达给内核，待内核把请求处理完毕后再将处理结果送回给用户空间。</p><img src="/assets/1600px-Linux_kernel_System_Call_Interface_and_glibc.C9hpPiIJ.webp" style="zoom:50%;"><h2 id="用户空间-用户态-和内核空间-内核态" tabindex="-1">用户空间（用户态）和内核空间（内核态） <a class="header-anchor" href="#用户空间-用户态-和内核空间-内核态" aria-label="Permalink to &quot;用户空间（用户态）和内核空间（内核态）&quot;">​</a></h2><p><a href="https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noreferrer">操作系统</a>的进程空间可分为<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4" target="_blank" rel="noreferrer">用户空间</a>和<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4" target="_blank" rel="noreferrer">内核空间</a>，它们需要不同的执行权限。其中系统调用运行在<a href="https://zh.wikipedia.org/wiki/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4" target="_blank" rel="noreferrer">内核空间</a>。</p><p>系统服务之所以需要通过系统调用来提供给用户空间的根本原因是为了对系统进行“保护”，因为我们知道 Linux 的运行空间分为内核空间与用户空间，它们各自运行在不同的级别中，逻辑上相互隔离。</p><p>所以用户进程在通常情况下不允许访问内核数据，也无法使用内核函数，它们只能在用户空间操作用户数据，调用用户空间函数。</p><p>比如我们熟悉的“hello world”程序（执行时）就是标准的用户空间进程，它使用的打印函数 printf 就属于用户空间函数，打印的字符“hello word”字符串也属于用户空间数据。</p><p>但是很多情况下，用户进程需要获得系统服务（调用系统程序），这时就必须利用系统提供给用户的“特殊接口”——系统调用了，它的特殊性主要在于规定了用户进程进入内核的具体位置。</p><p>换句话说，用户访问内核的路径是事先规定好的，只能从规定位置进入内核，而不准许肆意跳入内核。有了这样的陷入内核的统一访问路径限制才能保证内核安全无误。我们可以形象地描述这种机制：作为一个游客，你可以买票要求进入野生动物园，但你必须老老实实地坐在观光车上，按照规定的路线观光游览。当然，不准下车，因为那样太危险，不是让你丢掉小命，就是让你吓坏了野生动物。</p><h2 id="系统调用和库函数的区别" tabindex="-1">系统调用和库函数的区别 <a class="header-anchor" href="#系统调用和库函数的区别" aria-label="Permalink to &quot;系统调用和库函数的区别&quot;">​</a></h2><p>Linux 下对文件操作有两种方式：系统调用（system call）和库函数调用（Library functions）。</p><p>库函数由两类函数组成：</p><p>1）不需要调用系统调用</p><p>不需要切换到内核空间即可完成函数全部功能，并且将结果反馈给应用程序，如strcpy、bzero 等字符串操作函数。</p><p>2）需要调用系统调用</p><p>需要切换到内核空间，这类函数通过封装系统调用去实现相应功能，如 printf、fread等。</p><p><img src="/assets/image-20201205134837304.Dg7r5Ezx.webp" alt="" loading="lazy"></p><p>系统调用是需要时间的，程序中频繁的使用系统调用会降低程序的运行效率。当运行内核代码时，CPU工作在内核态，在系统调用发生前需要保存用户态的栈和内存环境，然后转入内核态工作。系统调用结束后，又要切换回用户态。这种环境的切换会消耗掉许多时间。</p>',21)]))}]]);export{i as __pageData,n as default};
