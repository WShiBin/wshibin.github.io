import{_ as e,c as t,a2 as o,o as s}from"./chunks/framework.DRc6tsBz.js";const r=JSON.parse('{"title":"【Test】译文:Googletest Primer","description":"","frontmatter":{"title":"【Test】译文:Googletest Primer","categories":"Test","tags":["Test","googletest"],"sidebar":false,"prev":false,"next":false,"comments":true,"date":"2020-05-30T22:03:18.000Z"},"headers":[],"relativePath":"posts/2020/05_30_Googletest-Primer.md","filePath":"posts/2020/05_30_Googletest-Primer.md","lastUpdated":1713284123000}');const a=e({name:"posts/2020/05_30_Googletest-Primer.md"},[["render",function(e,r,a,l,i,g){return s(),t("div",null,r[0]||(r[0]=[o('<h1 id="译文-googletest-primer" tabindex="-1">译文:Googletest Primer <a class="header-anchor" href="#译文-googletest-primer" aria-label="Permalink to &quot;译文:Googletest Primer&quot;">​</a></h1><p>文档:<a href="https://github.com/google/googletest/blob/master/googletest/docs/primer.md" target="_blank" rel="noreferrer">https://github.com/google/googletest/blob/master/googletest/docs/primer.md</a></p><h2 id="简介-为什么要使用googletest" tabindex="-1">简介:为什么要使用googletest? <a class="header-anchor" href="#简介-为什么要使用googletest" aria-label="Permalink to &quot;简介:为什么要使用googletest?&quot;">​</a></h2><p><em>googletest</em>能帮助你写更好的C++测试代码.</p><p>googletest是由测试技术团队根据Google的特定要求和约束来开发的测试框架. 不管你是在Linux,windows,还是Mac上工作,如果你写C++代码, googletest能帮助到你,它能支持运行任何类型的测试,不仅仅是支持unit tests.</p><p>那么什么是一个好的测试,以及googletest是如何做到这些的? 我们相信:</p><ol><li><strong>测试应该是独立和重复的</strong>.调试一个成功或是失败做其它测试的结果是一件很痛苦的事.googletest通过让他们运行在不同的object上来隔离它们.当一个测试fails,googletest允许你在单独的运行它进行快速调试</li><li><strong>测试应该组织得井井有条,并能反映出测试代码的结构</strong>.googletest将相关的测试分组到能共享数据和子程序的测试大几中,这个觉的落木模式让识别,并且使得测试易于维护.当人们切换项目,在新的代码仓库开始工作,这种一致性会非常的有用</li><li><strong>测试应该是可移植和可重复使用的</strong>.Google有很多和平台无关的代码,它们的测试也应该是和平台无关的.googletest能使用不同的编译器,使用或不使用异常,工作在不同的系统上.所以googletest能使用多种配置工作</li><li><strong>当测试失败,它们应该提供尽可能多的关于问题的信息</strong>.googletest不会在当第一个测试失败的时候停止,相反,它仅仅停止当前的测试,并会继续下一个测试,同时你也可以配置报告没有致命故障的测试,然后进行当前的测试.因此,你能在单个run-edit-compile循环中检测和修复多个bug.</li><li><strong>测试框架应该让测试者从乱七八糟的事情中解放出来,并专注于测试内容上</strong>.googletest会自动的跟踪所有的测试,并且不需要用户去列举他们,即可运行他们</li><li><strong>测试应该是非常快的</strong>.使用googletest,你能在不同的测试之间共享数据,这些只需要配置/拆卸一次,而不需要让测试相互依赖</li></ol><p>由于googletest基于流行的xUnit架构,如果你以前已经使用过JUnit或是PyUnit,你会感到宾至如归.如果没有使用过,它会话费大约10分钟去学习基础,然后开始</p><h2 id="基础概念" tabindex="-1">基础概念 <a class="header-anchor" href="#基础概念" aria-label="Permalink to &quot;基础概念&quot;">​</a></h2><p>当使用googletest,开始编写检查条件是不是真的<em>断言</em>,一个<em>断言</em>的结果可能是成功,非致命的故障,或是致命的故障.如果一个致命的故障出现了,它会终止当前的函数;反之,他会正常的继续运行</p><p>测试使用断言来验证用户的行为.如果测试崩溃或是有一个失败的断言,则这个测试失败了,反之这个测试成功了</p><p>一个测试套件包含一个或多个测试，你应该把测试组织到测试套件中，反映出整个的测试代码结构；当在测试套件中的多个测试需要共享一些常用数据对象和子程序的时候，你可以把他放在<strong>a test fixture</strong>类中。</p><p>一个测试程序能够包含多个测试套件</p><h2 id="断言" tabindex="-1">断言 <a class="header-anchor" href="#断言" aria-label="Permalink to &quot;断言&quot;">​</a></h2><p>googletest断言是一些类似函数调用的宏，可以通过对其很行为进行断言来测试类或函数，当一个断言失败，googletest打印这个断言的源代码和行号，和一些错误信息，同时也支持在消息后面追加一些自定义的错误信息</p><p>The assertions come in pairs that test the same thing but have different effects on the current function.</p><ul><li><p><code>ASSERT_*</code> 系列：当失败时生成一个致命错误，同时终止当前的函数</p></li><li><p><code>EXPECT_*</code> 系列：会生成非致命错误，意思是不会终止当前的函数运行。一般更加倾向于使用<code>EXPECT_*</code>，因为他能一次报告多个错误信息</p></li></ul><p>Since a failed <code>ASSERT_*</code> returns from the current function immediately, possibly skipping clean-up code that comes after it, it may cause a space leak. Depending on the nature of the leak, it may or may not be worth fixing - so keep this in mind if you get a heap checker error in addition to assertion errors.</p><p>To provide a custom failure message, simply stream it into the macro using the <code>&lt;&lt;</code> operator or a sequence of such operators. See the following example, using the <a href="https://google.github.io/googletest/reference/assertions.html#EXPECT_EQ" target="_blank" rel="noreferrer"><code>ASSERT_EQ</code> and <code>EXPECT_EQ</code></a> macros to verify value equality:</p>',19)]))}]]);export{r as __pageData,a as default};
