import{_ as s,c as i,o as a,a4 as l,l as n,a as h}from"./chunks/framework.s8d9Ue88.js";const k=JSON.parse('{"title":"【RTFC】spdlog源码分析","description":"","frontmatter":{"title":"【RTFC】spdlog源码分析","categories":"源码分析","tags":["spdlog","源码分析","RTFC"],"sidebar":false,"prev":false,"next":false,"comments":true,"date":"2022-04-24T23:40:36.000Z"},"headers":[],"relativePath":"posts/2022/04_24_spdlog源码分析.md","filePath":"posts/2022/04_24_spdlog源码分析.md","lastUpdated":1713886889000}'),p={name:"posts/2022/04_24_spdlog源码分析.md"},t=[l("",53),n("ol",null,[n("li",null,[h("registry单例模式 "),n("ol",null,[n("li",null,"map<name, logger>, 创建的异步日志会被添加到这里"),n("li",null,"defalut_logger"),n("li",null,[h("thread_pool线程池, (async_factory_impl) 异步才需要线程池 "),n("ol",null,[n("li",null,"details::mpmc_blocking_queue<async_msg>; 消息队列"),n("li",null,[h("std::vector"),n("a",{href:"std::thread",target:"_blank",rel:"noreferrer"},"std::thread"),h(" threads_; 具体线程")]),n("li",null,[h("void worker"),n("em",null,"loop"),h("() 死循环处理消息")])])]),n("li",null,[h("periodic"),n("em",null,"flusher"),h("; 周期性flush")]),n("li",null,"formatter_; log格式化"),n("li",null,"log_levels: 级别")])]),n("li",null,[h("工厂模式 "),n("ol",null,[n("li",null,"async_factory_impl"),n("li",null,"synchronous_factory")])]),n("li",null,[h("logger --\x3e async_logger "),n("ol",null,[n("li",null,[h("logger "),n("ol",null,[n("li",null,"std::string name*;*"),n("li",null,[h("std::vector<sink"),n("em",null,"ptr> sinks"),h(";")]),n("li",null,[h("spdlog::level"),n("em",{"level::info":""},"t level"),h(";_")]),n("li",null,[h("spdlog::level"),n("em",{"level::off":""},"t flush_level"),h(";")])])]),n("li",null,[h("async_logger "),n("ol",null,[n("li",null,[h("std::weak"),n("em",null,[h("ptr"),n("a",{href:"details::thread_pool",target:"_blank",rel:"noreferrer"},"details::thread_pool"),h(" thread_pool")]),h(";")]),n("li",null,[h("async"),n("em",null,"overflow_policy overflow_policy"),h(";")])])])])]),n("li",null,[h("多生产者,多消费者模型mpmc_blocking_q.h "),n("ol",null,[n("li",null,[h("log 环形队列circular_q --\x3e std::vector 实现 "),n("ol",null,[n("li",null,"async_overflow_policy::block"),n("li",null,"async_overflow_policy::overrun_oldest")])])])]),n("li",null,[h("log_msg--\x3e log_msg_buffer --\x3e async_msg "),n("ol",null,[n("li",null,[h("log_msg "),n("ol",null,[n("li",null,"string_view_t logger_name"),n("li",null,"level level"),n("li",null,"time_point time"),n("li",null,"thread_id"),n("li",null,"source_loc: 文件名, 行号, 函数名"),n("li",null,"string_view_t payload 消息主体")])]),n("li",null,[h("log_msg_buffer "),n("ol",null,[n("li",null,"memory_buf_t")])]),n("li",null,[h("async_msg "),n("ol",null,[n("li",null,"async_msg_type"),n("li",null,"async_logger_ptr --\x3e async_logger")])])])]),n("li",null,[h("sink基类; 日志输出到哪里去:文件,stdout, android, qt, tcp, upd, mongo, syslog, systemd "),n("ol",null,[n("li",null,"base_sink, 通用")])]),n("li",null,"流程")],-1)];const e=s(p,[["render",function(s,l,n,h,k,p){return a(),i("div",null,t)}]]);export{k as __pageData,e as default};
